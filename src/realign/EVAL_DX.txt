
# def evaluator(func):
#     return func

# Assumption: the user is aware whether the function is sync or async

@evaluator
def my_sync_func(*args, **kwargs):
    return 42

@evaluator
async def my_async_func(*args, **kwargs):
    return 42

# we will add some properties to the evaluator functions


@evaluator
def func(*args, **kwargs) -> EvalResult:
    score = 42
    metadata = {}
    return score, metadata

# func.settings is initialized with YAML settings if func.settings is None

# func.settings # property to set or override the settings
# func.raw() # the raw function call without settings

# func(*args, **kwargs, **settings_kwargs) # method to override the settings

# simple function call with YAML settings
r1 = func([1, 2, 3, 4, 5])

# simple function call without settings
r1 = func.raw([1, 2, 3, 4, 5])


# the __getitem__ method can be used to access the _eval_funcs global dict

r1 = evaluator['pymean']([1, 2, 3, 4, 5])

# this will pull up the default pymean settings in the config file and run the implementation of pymean with those settings

# to run with default settings
r1 = evaluator['pymean'].raw([1, 2, 3, 4, 5])

# to override certain settings
r1 = evaluator['pymean']([1, 2, 3, 4, 5], _weight=10)

## Add a new evaluator

@evaluator
def new_evaluator(*args, **kwargs) -> EvalResult:
    score = 42
    respons = evaluator['other_evaluator'](score)
    
    if new_evaluator.settings.target == 'good':
        score += 1

    return score

# everything with an evaluator decorator will be added to the _eval_funcs global dict

# this includes yaml evaluators

# running an evaluator using a function
# this allows you to pull the config for this evaluator
r2 = evaluator[new_evaluator]([1, 2, 3, 4, 5])

# wrap a sync function as an async function
import asyncio
r1 = asyncio.run(new_evaluator.a_sync([1, 2, 3, 4, 5]))

# wrap an async function as a sync function
async def async_evaluator(*args, **kwargs):
    return 42
r1 = async_evaluator.sync([1, 2, 3, 4, 5])


# chain evaluators
# we want to chain evaluators together

# chain func and new_evaluator
r1 = new_evaluator(new_evaluator(func([1, 2, 3, 4, 5])))

# from typing import Callable

# class evaluator(Callable):
#     def __init__(self, func):
#         self.func = func
#         self.call_count = 0

#     def __call__(self, *args, **kwargs):
#         self.call_count += 1
#         print(f"Call count: {self.call_count}")
#         return self.func(*args, **kwargs)

# @evaluator
# def say_hi(name):
#     print(f"Hi, {name}!")
